
    /*
    let s7 = split[6];
    let s8 = split[7];
    let s9 = split[8];
    let s10 = split[9];
    let s11 = split[10];
    let s12 = split[11];
    let s13 = split[12];
    let s14 = split[13];
    let s15 = split[14];
    let s16 = split[15];
    let s17 = split[16];
    let s18 = split[17];
    let s19 = split[18];
    let s20 = split[19];
    let s21 = split[20];
    let s22 = split[21];
    let s23 = split[22];
    let s24 = split[23];
    let s25 = split[24];
    let s26 = split[25];
    let s27 = split[26];
    let s28 = split[27];
    let s29 = split[28];
    let s30 = split[29];
    let s31 = split[30];
    let s32 = split[31];
    let s33 = split[32];
    let s34 = split[33];
    let s35 = split[34];
    let s36 = split[35];
    let s37 = split[36];
    let s38 = split[37];
    let s39 = split[38];
    let s40 = split[39];

    switch(number){
        case (number<=6):
            throw Error('Unsupported number of rows ' + number)
        case 7:
            parsedLines = ({date,s7});
        break;
        case 8:
            parsedLines = ({date,s7,s8});
            break;
        case 9:
            parsedLines = ({date,s7,s8,s9});
            break;
        case 10:
            parsedLines = ({date,s7,s8,s9,s10});
            break;
        case 11:
            parsedLines = ({date,s7,s8,s9,s10,s11});
            break;
        case 12:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12});
            break;
        case 13:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13});
            break;
        case 14:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14});
            break;
        case 15:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15});
            break;
        case 16:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16});
            break;
        case 17:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17});
            break;
        case 18:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18});
            break;
        case 19:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19});
            break;
        case 20:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20});
            break;
        case 21:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21});
            break;
        case 22:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22});
            break;
        case 23:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23});
            break;
        case 24:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24});
            break;
        case 25:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25});
            break;
        case 26:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26});
            break;
        case 27:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27});
            break;
        case 28:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28});
            break;
        case 29:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29});
            break;
        case 30:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30});
            break;
        case 31:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31});
            break;
        case 32:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32});
            break;
        case 33:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33});
            break;
        case 34:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34});
            break;
        case 35:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34,s35});
            break;
        case 36:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34,s35,s36});
            break;
        case 37:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34,s35,s36,s37});
            break;
        case 38:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34,s35,s36,s37,s38});
            break;
        case 39:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34,s35,s36,s37,s38,s39});
            break;
        case 40:
            parsedLines = ({date,s7,s8,s9,s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s20,s21,s22,s23,s24,s25,s26,s27,s28,s29,s30,s31,s32,s33,s34,s35,s36,s37,s38,s39,s40});
            break;


    }*/
//console.log(parsedLine)


   //  var sql= "ALTER TABLE txt_table  ADD (s8 double, s9 double) ";
        // connection.query(sql);

        var sql = "CREATE TABLE IF NOT EXISTS all_table (datum VARCHAR(255), s1 double, s2 double, s3 double,s4 double,s5 double)";
        connection.query(sql);
         //var sql= "ALTER TABLE all_table ADD (s18 double, s19 double) ";
       // connection.query(sql);


                       //console.log(A);
                      // var sql = "INSERT INTO txt_table VALUES ('"+A.date+"','"+A.columns[0]+"','"+A.columns[1]+"','"+A.columns[2]+"','"+A.columns[3]+"','"+A.columns[4]+"','"+A.columns[5]+"','"+A.columns[6]+"','"+A.columns[7]+"','"+A.columns[8]+"')";
                      // var insert =
                       //console.log(sql)

.        /*var column = [];
         for (let i = 0;i<9;i++){
             if (A.columns[i] === null){
                 A.columns[i] = 'null';
             }
             column.push(A.columns[i])
         }
         var sql = "INSERT INTO txt_table VALUES ('"+A.date+"'";
         var konec1 = [sql,column];
         var end = konec1.join(',')
         var zaver = [");"];
         var end1 = [end,zaver];
         var end2 = end1.join('');
         console.log(end2)
         console.log(end2)
         console.log(end2)
         connection.query(end2);*/


nacist do tabulkz ==y... kontrola velikosti.... nacteni podle casu, pokracovat  na radku konce... pomatovat radek

/*
let data = openFolder('data')//.then(() => {
        var minutes = 1, the_interval = minutes * 60 * 1000;
        setInterval(function () {
            console.log("I am doing my 1 minutes check");
            openFolder('data')

        }, the_interval);*/
        //saving to db
        import createConnection from './connection';
        import path from 'path';

        const getDates = fields => fields.map(field => field.date);
        const getColumns = fields => fields.map(field => field.columns);
        const getAll = fields => fields.map(field => field);

        var toOneArray = function(A) {
            let todb = [];
            for (let i = 0; i < A.length; i++) {
                let k = [A[i].date, ...A[i].columns];
                todb.push(k);
            }
            return todb;
        };

        export default (A, index, filename, oriniginalfileresult, fileSizeInBytes) => {
            if (oriniginalfileresult === false) {
                let connection = createConnection();
                var sqlfilename =
                    "INSERT INTO filename VALUES ('" +
                    index +
                    "','" +
                    filename +
                    "','" +
                    fileSizeInBytes +
                    "')";
                connection.query(sqlfilename);
                connection.end();
            }
            let c = getColumns(A);
            let d = getDates(A);
            let values = toOneArray(A);

            {
                var path = [foldername, filename[i]];
                var pathtosize = path.join('/');
                const stats = fs.statSync(pathtosize);
                const fileSizeInBytes = stats.size;

                if (!!result === false || result[0].filesize < fileSizeInBytes) {
                    loadFile(filename[i])
                        .then(A => {
                            savetodatabase(
                                A,
                                i,
                                filename[i],
                                !!result,
                                fileSizeInBytes
                            );
                            if (result[0].filesize < fileSizeInBytes) {
                                updatefilesize(fileSizeInBytes, i);
                            }
                        })
                        .catch(error => {
                            console.log('error openFolder');
                        });
                }
            }

            const extension = path
                .extname(filename)
                .split('.')[1]
                .toLocaleLowerCase();
            switch (extension) {
                case 'txt':
                    var sql = 'INSERT IGNORE INTO txt_table VALUES ?';
                    let connection1 = createConnection();

                    connection1.query(sql, [values], function(err, result) {
                        if (err) throw err;
                        console.log(
                            'Number of records inserted: ' + result.affectedRows
                        );
                        connection1.end();
                    });
                    break;
                case 'all':
                    let connection2 = createConnection();
                    var sql = 'INSERT IGNORE INTO all_table VALUES ?';
                    connection2.query(sql, [values], function(err, result) {
                        if (err) throw err;
                        console.log(
                            'Number of records inserted: ' + result.affectedRows
                        );
                        connection2.end();
                    });
                    break;
                case 'mol':
                    let connection3 = createConnection();
                    var sql = 'INSERT IGNORE INTO mol_table VALUES ?';
                    connection3.query(sql, [values], function(err, result) {
                        if (err) throw err;
                        console.log(
                            'Number of records inserted: ' + result.affectedRows
                        );
                        connection3.end();
                    });
                    break;
                case 'bud':
                    let connection4 = createConnection();
                    var sql = 'INSERT IGNORE INTO bud_table VALUES ? ';
                    connection4.query(sql, [values], function(err, result) {
                        if (err) throw err;
                        console.log(
                            'Number of records inserted: ' + result.affectedRows
                        );
                        connection4.end();
                    });
                    break;

                case 'vlh':
                    let connection5 = createConnection();
                    var sql = 'INSERT IGNORE INTO vlh_table VALUES ?';
                    connection5.query(sql, [values], function(err, result) {
                        if (err) throw err;
                        console.log(
                            'Number of records inserted: ' + result.affectedRows
                        );
                        connection5.end();
                    });
                    break;
            }
        };
let rowexists = mystring => {
    let connection = createConnection();
    return new Promise(resolve => {
        let sql = 'SELECT * FROM ?? WHERE ?? = ?';
        connection.query(sql, ['filename', 'name', mystring], function(
            error,
            result
        ) {
            if (result[0] === undefined) {
                result = false;
            }
            resolve(result);
            connection.end();
        });
    });
};

        /*
    switch (extension) {
        case 'all':
            readInterface.on('line', (line) => {
                let split = line.split(' ').filter(item => item !== '');
                output.push(columns(split, r_all));

                if (output.length >= 500) {
                    // TODO:

                    output = [];
                }
            });
            break;

        case 'txt':

            readInterface.on('line', (line) => {
                i++;
                if (i === 1) {
                    return;
                }
                let split = line.split(' ').filter(item => item !== '');
                output.push(columns(split, r_txt));
            });
            break;

        case 'mol':

            readInterface.on('line', (line) => {
                let split = line.split(' ').filter(item => item !== '');
                output.push(columns(split, r_mol));
            });
            break;

        case 'bud':
            readInterface.on('line', (line) => {
                let split = line.split(' ').filter(item => item !== '');
                output.push(columns(split, r_bud));
                });
            break;

        case 'vlh':

            readInterface.on('line', (line) => {
                let split = line.split(' ').filter(item => item !== '');
                output.push(columns(split, r_vlh));
            });
            break;
    }

        readInterface.on('close', () => {
            // TODO
            // output

        })*/

                    /*

                    for (let i = 0; i < filename.length; i++) {
                        rowexists(filename[i]).then((result) => {

                            var path = [foldername, filename[i]];
                            var pathtosize = path.join('/');
                            const stats = fs.statSync(pathtosize);
                            const fileSizeInBytes = stats.size;


                            if(!!result  === false||result[0].filesize<fileSizeInBytes) {


                            loadFile(f ilename[i]).then((A) => {


                                savetodatabase(A, i, filename[i], !!result,fileSizeInBytes)
                                if (result[0].filesize<fileSizeInBytes) {
                                    updatefilesize(fileSizeInBytes, i)
                                }
                            }).catch((error) => {
                                console.log("error openFolder")

                            })

                        }
                        })
                    }*/

                    # prumer
                    select day_at, avg(temp) from table_name group by day_at;

                    # max
                    select day_at, max(temp) from table_name group by day_at;

                    # min
                    select day_at, min(temp) from table_name group by day_at;


                    # sum
                    select day_at, sum(temp) from table_name group by day_at;

                    class calendar extends Component {
                        constructor(props) {
                            super(props);
                            this.state = {
                                startDate: null,
                                endDate: null
                            }
                        }

                        render() {
                            return (

                                    <DateRangePicker
                                        startDate={this.state.startDate} // momentPropTypes.momentObj or null,
                                        startDateId="your_unique_start_date_id" // PropTypes.string.isRequired,
                                        endDate={this.state.endDate} // momentPropTypes.momentObj or null,
                                        endDateId="your_unique_end_date_id" // PropTypes.string.isRequired,
                                        isOutsideRange={() => false}
                                        onDatesChange={({startDate, endDate}) => this.setState({
                                            startDate,
                                            endDate
                                        })} // PropTypes.func.isRequired,
                                        focusedInput={this.state.focusedInput} // PropTypes.oneOf([START_DATE, END_DATE]) or null,
                                        onFocusChange={focusedInput => this.setState({focusedInput})} // PropTypes.func.isRequired,
                                    />


                            )
                        }
                    }